#!/usr/bin/python
# coding: utf-8 -*-

# (c) 2014, Koert van der Veer <koert@cloudvps.com>
# (c) 2013, Benno Joy <benno@ansible.com>
# (c) 2013, John Dewey <john@dewey.ws>
#
# This module is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this software.  If not, see <http://www.gnu.org/licenses/>.

try:
    from novaclient.v1_1 import client as nova_client
    from novaclient import exceptions
    import time
    import traceback
except ImportError:
    print("failed=True msg='novaclient is required for this module'")

DOCUMENTATION = '''
---
module: nova_compute
version_added: "1.2"
short_description: Create/Delete VMs from OpenStack
description:
   - Create or Remove virtual machines from Openstack.
options:
   login_user:
     description:
        - login username to authenticate to keystone
     required: false
     default: admin
   login_password:
     description:
        - Password of login user
     required: false
     default: 'yes'
   login_tenant_name:
     description:
        - The name of the tenant login_user belongs to
     required: false
     default: None
   login_tenant_id:
     description:
        - The id of the tenant login_user belongs to
     required: false
     default: None
   token:
     description:
        - The token to be used in case the password is not specified
     required: false
     default: None
   endpoint:
     description:
        - The admin url for keystone
     required: false
     default: None
   endpoint_type:
     description:
        - The type of endpoint to use from the service catalog
     required: false
     default: 'publicURL'
   region_name:
     description:
        - The region to use when selecting an endpoint from the service catalog
     required: false
     default: None

   state:
     description:
        - Indicate desired state of the resource
     choices: ['present', 'absent']
     default: present
   name:
     description:
        - Name that has to be given to the instance
     required: true
     default: None
   image_id:
     description:
        - The id of the image that has to be cloned
     required: true
     default: None
   flavor_id:
     description:
        - The id of the flavor in which the new VM has to be created
     required: false
     default: 1
   key_name:
     description:
        - The key pair name to be used when creating a VM
     required: false
     default: None
   security_groups:
     description:
        - The name of the security group to which the VM should be added
     required: false
     default: None
   nics:
     description:
        - A list of network id's to which the VM's interface should be attached
     required: false
     default: None
   meta:
     description:
        - A list of key value pairs that should be provided as a metadata to the new VM
     required: false
     default: None
   wait:
     description:
        - If the module should wait for the VM to be created.
     required: false
     default: 'yes'
   wait_for:
     description:
        - The amount of time the module should wait for the VM to get into active state
     required: false
     default: 180
requirements: ["novaclient"]
'''

EXAMPLES = '''
# Creates a new VM and attaches to a network and passes metadata to the instance
- nova_compute:
    state: present
    login_username: admin
    login_password: admin
    login_tenant_name: admin
    name: vm1
    image_id: 4f905f38-e52a-43d2-b6ec-754a13ffb529
    key_name: ansible_key
    wait_for: 200
    flavor_id: 4
    nics:
      - net-id: 34605f38-e52a-25d2-b6ec-754a13ffb723
    meta:
      hostname: test1
      group: uge_master
'''


def delete_server(module, nova):
    name = None
    server_list = None
    try:
        server_list = nova.servers.list(True, {'name': module.params['name']})
        if server_list:
            server = [x for x in server_list
                      if x.name == module.params['name']]
            nova.servers.delete(server.pop())
    except Exception, e:
        module.fail_json(msg="Error in deleting vm: %s" % e.message)

    if not module.params['wait']:
        module.exit_json(changed=True, result="deleted")

    expire = time.time() + int(module.params['wait_for'])
    while time.time() < expire:
        name = nova.servers.list(True, {'name': module.params['name']})
        if not name:
            module.exit_json(changed=True, result="deleted")
        time.sleep(5)

    module.fail_json(msg="Timed out waiting for server to get deleted, "
                         "please check manually")


def rebuild_server(module, nova, server):
    server.rebuild(module.params['image_id'])

    state = get_server_state(module, nova, server)
    module.exit_json(changed=True, **state)


def create_server(module, nova):
    bootargs = [module.params['name'],
                module.params['image_id'],
                module.params['flavor_id']]

    security_groups = module.params['security_groups']
    security_groups = (security_groups
                       if isinstance(security_groups, basestring)
                       else security_groups.split(','))

    nics = module.params['nics']
    nics = nics.split if isinstance(nics, basestring) else nics.split(',')

    bootkwargs = {
        'nics': nics,
        'meta': module.params['meta'],
        'key_name': module.params['key_name'],
        'security_groups': security_groups,
    }

    if not module.params['key_name']:
        del bootkwargs['key_name']

    try:
        server = nova.servers.create(*bootargs, **bootkwargs)
    except Exception, e:
        module.fail_json(msg="Error in creating instance: %s " % e.message,
                         bootargs=bootargs, bootkwargs=bootkwargs,
                         tb=traceback.format_exc()
                         )

    state = get_server_state(module, nova, server)

    module.exit_json(changed=True, **state)


def get_server_state(module, nova, server):

    if module.params['wait']:
        # We need to wait until the server is active
        expire = time.time() + float(module.params['wait_for'])
        while time.time() < expire:
            try:
                server = nova.servers.get(server.id)
            except Exception, e:
                module.fail_json(msg="Error in getting info from instance: %s " % e.message)

            if server.status in ('ACTIVE', 'ERROR'):
                break

            time.sleep(2)

        if server.status not in ('ACTIVE', 'ERROR'):
            module.fail_json(msg="Timeout waiting for the server to come up. "
                                 "Please check manually.")

    if server.status == 'ERROR':
        module.fail_json(msg="Server failed to boot. "
                             "Please check manually")

    fixed_ips = [x['addr'] for x in server.addresses.values()[0]
                 if x.get('OS-EXT-IPS:type') == 'fixed']
    floating_ips = [x['addr'] for x in server.addresses.values()[0]
                    if x.get('OS-EXT-IPS:type') == 'floating']

    return dict(id=server.id,
                # misnomer for backward compatibility
                private_ip=''.join(fixed_ips),
                public_ip=''.join(floating_ips),
                status=server.status,
                info=server._info)


def get_server(module, nova):
    try:
        servers = nova.servers.list(True, {'name': module.params['name']})
        if servers:
            return [x for x in servers if x.name == module.params['name']][0]
    except Exception, e:
        module.fail_json(msg="Error in getting the server list: %s" % e.message)


def main():
    argument_spec = os_argument_spec()
    argument_spec.update(dict(
        name=dict(required=True),
        image_id=dict(default=None),
        flavor_id=dict(default=1),
        key_name=dict(default=None),
        security_groups=dict(default='default'),
        nics=dict(default=None),
        meta=dict(default=None),
        wait=dict(default='yes', type='bool'),
        wait_for=dict(default=180),
        state=dict(default='present', choices=['absent', 'present'])
    ))

    module = AnsibleModule(
        argument_spec=argument_spec,
        supports_check_mode=True,
        mutually_exclusive=os_mutually_exclusive()
    )

    nova = nova_client.Client(module.params['login_username'],
                              module.params['login_password'],
                              module.params['login_tenant_name'],
                              module.params['auth_url'],
                              service_type='compute')
    try:
        nova.authenticate()
    except exc.Unauthorized, e:
        module.fail_json(msg = "Invalid OpenStack Nova credentials.: %s" % e.message)
    except exc.AuthorizationFailure, e:
        module.fail_json(msg = "Unable to authorize user: %s" % e.message)

    if module.params['state'] == 'present':
        if not module.params['image_id']:
            module.fail_json(msg="Parameter 'image_id' is required "
                                 "if state == 'present'")

        server = get_server(module, nova)
        if server:
            state = get_server_state(module, nova, server)
            module.exit_json(changed=False, **state)

        create_server(module, nova)

    elif module.params['state'] == 'absent':
        get_server_state(module, nova)
        delete_server(module, nova)
    elif module.params['state'] == 'rebuilt':
        if not module.params['image_id']:
            module.fail_json(msg="Parameter 'image_id' is required "
                                 "if state == 'present'")

        server = get_server(module, nova)
        if server:
            rebuild_server(module, nova, server)
        else:
            create_server(module, nova)

from ansible.module_utils.basic import *
from ansible.module_utils.openstack import *
if __name__ == '__main__':
    main()
